Consider a situation where a base class have declared a perfect forwarding constructor,
but this will typically involve calling base class constructor when we have copy and move
function instances. 
Some functions are generated by compilers and might bypass the tag-dispatch system.

We can do it using std::enable_if by giving it the condition under which the templates
are enabled only if condition is satisfied.

```
class Car{
	template<typename T,
				typename = typename std::enable_if<condition>::type>
	Car(T&& carname);
};
```
We want to enable the function only if the type itself is not the Car object.
so, !Car something along the lines.

we can use std::is_same<Car,T>::value, but the problem is we wouldn't also want 
Car&, Car*, const Car, and all those types to be included too...
so capture them all. We can use std::decay, which removes all modifiers.
So, the condition we want is 
```
!(std::is_same<Car, typename std::decay<T>::type>::value)
```

This solves the problem huh!??? No it doesn't, 

But what if we have derived class from Car
as 
```
class TATA: public Car{
	public:
		TATA(const TATA& lvalue): Car(lvalue){} 
		TATA(TATA&& rvalue) : Car(std::move(rvalue)){} 
};
```

here copy constructor calls base class forwarding constructor as it is not of type Car.
We have only excluded type Car. 

So, here we can use std::is_base_of which tells us if the class is derived from the 
base class B.

std::is_base_of<B,D>::value is true if D is derived from Base B.

also all classes are derived from themselves. So, instead of using std::is_equal,
we can use std::is_base_of.

```
class Car{
	public:
		template<typename T,
				typename = typename std::enable_if<
				!std::is_base_of<Car,
								typename std::decay<T>::type>::value>::type>
		Car(T&& carname);
}
```

Also let's consider we also don't want the type to be int and it's related types.

```
class Car{
	public:
		template<typename T,
				typename = std::enable_if_t<
				!std::is_base_of<Car, std::decay_t<T>::type>::value
				&&
				!std::is_integral<std::remove_reference_t<T>::value
				>::type>
		Car(T&& carname){}
}	
```
